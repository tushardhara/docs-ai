package media

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
)

const (
	mediaTypeImage  = "image"
	contentTypeText = "text"
)

// MediaOrchestrator routes media items to the appropriate handler based on type
type MediaOrchestrator struct {
	ocrHandler     *GoogleVisionOCR
	youtubeHandler *YouTubeTranscriptFetcher
	videoHandler   *VideoTranscriber
	logger         *slog.Logger
}

// NewMediaOrchestrator creates a new orchestrator with all media handlers
func NewMediaOrchestrator(logger *slog.Logger) (*MediaOrchestrator, error) {
	if logger == nil {
		logger = slog.Default()
	}

	ocrHandler, err := NewGoogleVisionOCR(context.Background(), logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create OCR handler: %w", err)
	}

	return &MediaOrchestrator{
		ocrHandler:     ocrHandler,
		youtubeHandler: NewYouTubeTranscriptFetcher(logger),
		videoHandler:   NewVideoTranscriber(logger),
		logger:         logger,
	}, nil
}

// ProcessMediaItem routes a media item to the appropriate handler and returns extracted content
func (o *MediaOrchestrator) ProcessMediaItem(ctx context.Context, item *MediaItem) (*ExtractedContent, error) {
	o.logger.Info("Processing media item", "type", item.Type, "url", item.URL)

	switch item.Type {
	case mediaTypeImage:
		return o.processImage(ctx, item)
	case "youtube":
		return o.processYouTube(ctx, item)
	case "video":
		return o.processVideo(ctx, item)
	default:
		return nil, fmt.Errorf("unsupported media type: %s", item.Type)
	}
}

// processImage handles image OCR extraction
func (o *MediaOrchestrator) processImage(ctx context.Context, item *MediaItem) (*ExtractedContent, error) {
	o.logger.Debug("Processing image with OCR", "url", item.URL)

	result, err := o.ocrHandler.ExtractFromURL(ctx, item.URL)
	if err != nil {
		return nil, fmt.Errorf("OCR extraction failed: %w", err)
	}

	return &ExtractedContent{
		MediaItemID: item.ID,
		Text:        result.Text,
		Language:    result.Language,
		Confidence:  result.ConfidenceScore,
		ExtractedAt: item.CreatedAt,
		ContentType: contentTypeText,
		Metadata:    map[string]interface{}{"ocr": true},
		Status:      determineStatus(result.Text, result.ConfidenceScore),
	}, nil
}

// processYouTube handles YouTube transcript extraction
func (o *MediaOrchestrator) processYouTube(ctx context.Context, item *MediaItem) (*ExtractedContent, error) {
	o.logger.Debug("Processing YouTube video", "url", item.URL)

	// Extract video ID
	videoID, err := o.youtubeHandler.ExtractVideoIDFromURL(item.URL)
	if err != nil || videoID == "" {
		return nil, fmt.Errorf("invalid YouTube URL: %s", item.URL)
	}

	result, err := o.youtubeHandler.GetTranscript(ctx, videoID)
	if err != nil {
		return nil, fmt.Errorf("YouTube transcript extraction failed: %w", err)
	}

	// Convert segments to metadata
	segments := make([]map[string]interface{}, 0, len(result.Segments))
	for _, seg := range result.Segments {
		segments = append(segments, map[string]interface{}{
			"text":          seg.Text,
			"start_seconds": seg.StartSeconds,
			"end_seconds":   seg.EndSeconds,
		})
	}

	return &ExtractedContent{
		MediaItemID: item.ID,
		Text:        result.Transcript,
		Language:    result.Language,
		Confidence:  1.0, // YouTube transcripts typically high confidence
		ExtractedAt: item.CreatedAt,
		ContentType: "transcript",
		Metadata: map[string]interface{}{
			"youtube":           true,
			"video_id":          videoID,
			"segments":          segments,
			"is_auto_generated": result.IsAutoGenerated,
			"duration":          result.Duration,
		},
		Status: determineStatusFromText(result.Transcript),
	}, nil
}

// processVideo handles direct video file transcription
func (o *MediaOrchestrator) processVideo(ctx context.Context, item *MediaItem) (*ExtractedContent, error) {
	o.logger.Debug("Processing video file", "url", item.URL)

	result, err := o.videoHandler.TranscribeFromURL(ctx, item.URL)
	if err != nil {
		return nil, fmt.Errorf("video transcription failed: %w", err)
	}

	// Convert segments to metadata
	segments := make([]map[string]interface{}, 0, len(result.Segments))
	for _, seg := range result.Segments {
		segments = append(segments, map[string]interface{}{
			"text":          seg.Text,
			"start_seconds": seg.StartSeconds,
			"end_seconds":   seg.EndSeconds,
		})
	}

	return &ExtractedContent{
		MediaItemID: item.ID,
		Text:        result.Transcript,
		Language:    result.Language,
		Confidence:  0.95, // Speech-to-text typically high confidence
		ExtractedAt: item.CreatedAt,
		ContentType: "transcript",
		Metadata: map[string]interface{}{
			"video":             true,
			"segments":          segments,
			"is_auto_generated": result.IsAutoGenerated,
			"duration":          result.Duration,
		},
		Status: determineStatusFromText(result.Transcript),
	}, nil
}

// DetectMediaType detects media type from URL or content
func (o *MediaOrchestrator) DetectMediaType(url string) string {
	urlLower := strings.ToLower(url)

	// YouTube detection
	if strings.Contains(urlLower, "youtube.com") || strings.Contains(urlLower, "youtu.be") {
		return "youtube"
	}

	// Image detection by extension
	imageExts := []string{".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg", ".tiff"}
	for _, ext := range imageExts {
		if strings.HasSuffix(urlLower, ext) {
			return "image"
		}
	}

	// Video detection by extension
	videoExts := []string{".mp4", ".avi", ".mov", ".mkv", ".webm", ".flv", ".wmv", ".m4v"}
	for _, ext := range videoExts {
		if strings.HasSuffix(urlLower, ext) {
			return "video"
		}
	}

	// Default to image if unsure (most common case)
	o.logger.Warn("Could not detect media type, defaulting to image", "url", url)
	return "image"
}

// GetSupportedTypes returns list of supported media types
func (o *MediaOrchestrator) GetSupportedTypes() []string {
	return []string{"image", "youtube", "video"}
}

// Close cleans up resources
func (o *MediaOrchestrator) Close() error {
	if o.ocrHandler != nil {
		if err := o.ocrHandler.Close(); err != nil {
			return fmt.Errorf("failed to close OCR handler: %w", err)
		}
	}
	return nil
}

// Helper functions

func determineStatus(text string, confidence float64) string {
	if text == "" {
		return "failed"
	}
	if confidence < 0.5 {
		return "partial"
	}
	return "success"
}

func determineStatusFromText(text string) string {
	if text == "" {
		return "failed"
	}
	if strings.Contains(text, "[Mock]") || strings.Contains(text, "Placeholder") {
		return "partial"
	}
	return "success"
}
