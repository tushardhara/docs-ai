package media

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

// YouTubeVideoProcessor downloads YouTube videos and extracts text via OCR
type YouTubeVideoProcessor struct {
	ocr       OCRHandler
	logger    *slog.Logger
	tempDir   string
	maxFrames int
}

// NewYouTubeVideoProcessor creates a new YouTube video processor
func NewYouTubeVideoProcessor(ocrHandler OCRHandler, logger *slog.Logger) *YouTubeVideoProcessor {
	if logger == nil {
		logger = slog.Default()
	}

	return &YouTubeVideoProcessor{
		ocr:       ocrHandler,
		logger:    logger,
		tempDir:   os.TempDir(),
		maxFrames: 10,
	}
}

// GetTranscript downloads video and extracts text from frames via OCR
func (y *YouTubeVideoProcessor) GetTranscript(ctx context.Context, videoID string) (*TranscriptResult, error) {
	if videoID == "" {
		return nil, fmt.Errorf("%w: video ID is empty", ErrInvalidURL)
	}

	y.logger.Info("Processing YouTube video", "videoID", videoID)

	// Download video using yt-dlp
	videoPath, duration, err := y.downloadVideo(ctx, videoID)
	if err != nil {
		y.logger.Error("Failed to download video", "error", err, "videoID", videoID)
		return nil, fmt.Errorf("%w: failed to download video: %v", ErrExtractionFailed, err)
	}
	defer os.Remove(videoPath)

	// Extract frames
	framePaths, err := y.extractFrames(ctx, videoPath, duration)
	if err != nil {
		y.logger.Error("Failed to extract frames", "error", err)
		return nil, fmt.Errorf("%w: failed to extract frames: %v", ErrExtractionFailed, err)
	}
	defer func() {
		for _, frame := range framePaths {
			os.Remove(frame)
		}
	}()

	// OCR each frame and combine text
	segments := []TranscriptSegment{}
	var allText strings.Builder

	for i, framePath := range framePaths {
		ocrResult, err := y.ocr.ExtractFromFile(ctx, framePath)
		if err != nil {
			y.logger.Warn("OCR failed for frame", "frame", i, "error", err)
			continue
		}

		if ocrResult.Text != "" {
			allText.WriteString(ocrResult.Text)
			allText.WriteString("\n\n")

			timestamp := (duration / len(framePaths)) * i

			segments = append(segments, TranscriptSegment{
				Text:         ocrResult.Text,
				StartSeconds: timestamp,
				EndSeconds:   timestamp + (duration / len(framePaths)),
			})

			y.logger.Debug("Frame OCR result", "frame", i, "textLength", len(ocrResult.Text))
		}
	}

	result := &TranscriptResult{
		Transcript:      allText.String(),
		Language:        "en",
		Duration:        duration,
		IsAutoGenerated: false,
		Segments:        segments,
	}

	y.logger.Info("Video processing complete",
		"videoID", videoID,
		"framesProcessed", len(framePaths),
		"textLength", len(result.Transcript))

	return result, nil
}

// downloadVideo downloads a YouTube video using yt-dlp
func (y *YouTubeVideoProcessor) downloadVideo(ctx context.Context, videoID string) (string, int, error) {
	url := fmt.Sprintf("https://www.youtube.com/watch?v=%s", videoID)
	outputPath := filepath.Join(y.tempDir, fmt.Sprintf("video_%s.mp4", videoID))

	cmd := exec.CommandContext(ctx, "yt-dlp",
		"-f", "best[ext=mp4]",
		"-o", outputPath,
		url)

	if err := cmd.Run(); err != nil {
		return "", 0, fmt.Errorf("yt-dlp failed: %w", err)
	}

	duration, err := y.getVideoDuration(ctx, outputPath)
	if err != nil {
		return "", 0, fmt.Errorf("failed to get duration: %w", err)
	}

	return outputPath, duration, nil
}

// extractFrames extracts key frames from video using ffmpeg
func (y *YouTubeVideoProcessor) extractFrames(ctx context.Context, videoPath string, duration int) ([]string, error) {
	frameDir := filepath.Join(y.tempDir, fmt.Sprintf("frames_%d", os.Getpid()))
	if err := os.MkdirAll(frameDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create frame directory: %w", err)
	}

	outputPattern := filepath.Join(frameDir, "frame_%03d.jpg")
	cmd := exec.CommandContext(ctx, "ffmpeg",
		"-i", videoPath,
		"-vf", "fps=1/2",
		"-vframes", strconv.Itoa(y.maxFrames),
		outputPattern)

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("ffmpeg failed: %w", err)
	}

	entries, err := os.ReadDir(frameDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read frame directory: %w", err)
	}

	var frames []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".jpg") {
			frames = append(frames, filepath.Join(frameDir, entry.Name()))
		}
	}

	return frames, nil
}

// getVideoDuration gets video duration in seconds using ffprobe
func (y *YouTubeVideoProcessor) getVideoDuration(ctx context.Context, videoPath string) (int, error) {
	cmd := exec.CommandContext(ctx, "ffprobe",
		"-v", "error",
		"-show_entries", "format=duration",
		"-of", "default=noprint_wrappers=1:nokey=1:noprint_wrappers=1",
		videoPath)

	output, err := cmd.Output()
	if err != nil {
		return 0, fmt.Errorf("ffprobe failed: %w", err)
	}

	durationStr := strings.TrimSpace(string(output))
	duration, err := strconv.ParseFloat(durationStr, 64)
	if err != nil {
		return 0, fmt.Errorf("failed to parse duration: %w", err)
	}

	return int(duration), nil
}

// ExtractVideoIDFromURL extracts the video ID from a YouTube URL
func (y *YouTubeVideoProcessor) ExtractVideoIDFromURL(url string) (string, error) {
	patterns := []string{
		`(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)`,
		`youtube\.com\/embed\/([^&\n?#]+)`,
		`youtube\.com\/v\/([^&\n?#]+)`,
	}

	for _, pattern := range patterns {
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(url)
		if len(matches) > 1 {
			return matches[1], nil
		}
	}

	return "", fmt.Errorf("%w: could not extract video ID from %s", ErrInvalidURL, url)
}
